# Pages and Components

A website is made up of pages.  Even a web *app* has pages.  Thus, the most basic way to create dynamic behavior with Brut is the
*page*.  In Brut, a page is a URL, a subclass of {Brut::FrontEnd::Page}, and an ERB template.  The template is rendered in the context
of an instance of the class whenever the URL is requested.

## Overview of Rendering Pages

In your `app.rb`, you first declare a page using the {Brut::SinatraHelpers::ClassMethods#page} method (inside the block given to {Brut::Framework::App.routes}):

    class App < Brut::Framework::App

      routes do

        page "/sign_in"
      end
    end

The name of the route must start with a `/` and the rest of the route determines the name of the page.  In the example above, Brut
will expect to find a class named `SignInPage`, which should be located in `app/src/front_end/pages`.  You can create it with
`bin/scaffold`:

    > bin/scaffold page SignInPage

The page class must subclass {Brut::FrontEnd::Page}.  You write a constructor to accept whatever your page needs to assemble the data
needed to render it.

The HTML is generated based on an ERB file located in `app/src/front_end/pages`.  In this example, that's
`app/src/front_end/pages/sign_in_page.html.erb`.  That ERB is executed with an instance of the page class as context.  That means you
can references any methods or ivars.

## Creating a Page Class

{Brut::FrontEnd::Page#render} is called by Brut and expects to receive HTML, which it will send as the body of the response. `render`
manages the ERB rendering, so the bulk of your page's logic will be in other methods.  The constructor is where any data you need is
provided.

A page's `initialize` method must accept only keyword arguments and those keywords are used by Brut to determine what data needs to be
passed in.  This technique, called *{file:doc-src/keyword-injection.md Keyword Injection}*, is used in several other places in Brut.

When the page's URL is requested, an instance of your page class is created, passing in the values needed.  Beyond that, however, your page class is a normal Ruby class. You can save data to instance variables, implement attributes or other methods. Basically, whatever logic your page needs to render will exist in the page class.

## Implementing Your ERB

ERB is part of the Ruby standard library that allows the creation of dynamic templates.  Brut's ERB is close to this implementation, but has a few additional features that make working with HTML a bit safer.

### Your Page is the Only Context

The instance of your page class is the only context available to the ERB.  There is no set of global helpers that are injected, nor
are there any modules added when the page is rendered.  Anything you need to do in your ERB must be available to the page class you've
created.

The reason for this is to keep things simple.  If your page's HTML needs access to a lot of stuff, your page class will be the source
of truth as to where that stuff comes from.  You will always be able to figure out where methods are defined by looking at the page
class or any of its ancestors.  You are free to `include` as many modules as you like, or dump lots of methods into your `AppPage`
base class. But you don't have to.

### All Strings are HTML-Escaped

Any instance of a `String` is HTML-escaped by Brut before being inserted into the HTML being generated by the ERB.  This is, generally, what you want to have happen.  If you have a string that you believe is safe and does not need to be escaped, you can prevent HTML-escaping in one of two ways:

* Call {Brut::FrontEnd::Component#html_safe!} on the string

        <%= html_safe!(get_value) %>

* Wrap the string in a {Brut::FrontEnd::Templates::HTMLSafeString}.

        def get_value
          Brut::FrontEnd::Templates::HTMLSafeString.from_string(some_value)
        end

  This is what `html_safe!` does and this is what Brut does internally. Brut doesn't monkey-patch `String`. A `String` is always
  considered unsafe, and an `HTMLSafeString` is always considered safe.

Both of these methods are verbose, but this is on purpose.  You generally don't want un-escaped HTML going into your HTML, but if you
do, you may find it better to create a component (see below), or use {Brut::FrontEnd::Component::Helpers#html_tag} to generate markup.

### Pages Have Layouts

The page's ERB is rendered in the context of a *layout*.  A Layout works similar to how it works in Rails. It's intended to hold HTML
needed by every page of your app. A minimal layout might look like so:

    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="utf-8">
        <%= component(Brut::FrontEnd::Components::PageIdentifier.new(self.page_name)) %>
        <link rel="preload" as="style" href="<%= asset_path('/css/styles.css') %>">
        <link rel="stylesheet"         href="<%= asset_path('/css/styles.css') %>">
        <script defer src="<%= asset_path('/js/app.js') %>"></script>
      </head>
      <body>
        <%= yield %>
      </body>
    </html>

The layout is rendered in the context of the page class, so every page must provide whatever features are needed by the layout. This
is usually done by adding globally-used functions to `AppPage`, which is the base class of all your app's pages.

A page can use another layout by overriding {Brut::FrontEnd::Page#layout}.  The string returned must match a file in
`app/src/front_end/layouts/`.

### There Are No Partials

Rails partials are not part of ERB, and Brut does not include this feature. Instead, you would use *Components*.

## Decompose and Re-Use with Components

*Components* in Brut are very similar to the View Components library, though somewhat simpler.  A component is a class and an ERB
template.  That template is rendered in the context of an instance of the class.  That class is created the same way a page is and has
a `render` method that works just like a page's.

This is all because {Brut::FrontEnd::Page} extends {Brut::FrontEnd::Component}.  A page adds the concept of a layout, but generally a
page and a component are the same thing.

### Using Components

The main difference from your perspective is that generally *you* create instances of components.  This means that your page must have
access to any data a component needs.  When you've created your component instance, use {Brut::FrontEnd::Component#component} to
render it:

    <%= component(Button.new(type: :danger, label: "Cancel Subscription")) %>

### Components with Templates

The most common way to use a component is with an ERB template. It is expected to be in `app/src/front_end/components`.  For the
hypothetical `Button` component above, Brut would expect `app/src/front_end/components/button.html.erb` to exist as a template.

Just like a page, the component's ERB is rendered in the context of the component only.

Sometimes, components are simple enough that you don't need HTML.

### Components That Render Themselves

While overriding `render` in a page is generally discouraged, {Brut::FrontEnd::Component#render} can be overridden if you want to
generate HTML yourself.  The best way to do that is with {Brut::FrontEnd::Component::Helpers#html_tag}, though you can always return a
`String` or {Brut::FrontEnd::Templates::HTMLSafeString} that you've created yourself. Just remeber that all `String` instances will be
HTML-escaped.

As an example, here is how you might have a Markdown component that renders Markdown as HTML:

    class MarkdownComponent < AppComponent
      def initialize(markdown:)
        @markdown = markdown
        @renderer = Redcarpet::Markdown.new(
          Redcarpet::Render::HTML.new(
            filter_html: true,
            no_images: true,
            no_styles: true,
            safe_links_only: true,
          ),
          fenced_code_blocks: true,
          autolink: true,
          quote: true,
        )
      end

      def render
       html_safe!(@renderer.render(@markdown.to_s))
      end
    end


### Global Components

While a component is just a class with an initializer, sometimes you need a component that is generally useful on any page, but that
you don't want to initialize.  For example, if your component needs access to the flash, but your page does not, you don't want your
page to require a flash just to pass to the component.  In that case, a *global component* can be used and Brut will instantiate it.

{Brut::FrontEnd::Component#component} can be given a class, and Brut will use keyword injection to create it.  Consider a generic
flash component:

    class GlobalFlash < AppComponent

      attr_reader :flash

      def initialize(flash:)
        @flash = flash
      end
    end

You can use this anywhere like so:

    <%= component(GlobalFlash) %>

Because the flash is availble from the {Brut::FrontEnd::RequestContext}, Brut can create this component when needed.

## Testing Pages and Components

Pages and Components are classes with a constructor you create and a well-defined primary method called `render`.  This means you can
test them conventionally, since they can be directly created in your tests.

That said, you likely want to test the generated HTML and not the methods of the class.  All tests of a page or component have the
methods in {Brut::SpecSupport::ComponentSupport} available.  Of particular interest is
{Brut::SpecSupport::ComponentSupport#render_and_parse}.

This method accepts an instance of a page or component, parses the resulting HTML with Nokogiri, and returns a
{Brut::SpecSupport::EnhancedNode}, which wraps a `Nokogiri::XML::Node` or `Nokogiri::XML::Element`, depending on what was parsed.  You
can then use Nokogiri's API locate elements and assert on them.

To keep close to the web platform, it's recommended to use CSS selectors either via {Brut::SpecSupport::EnhancedNode#e} or {Brut::SpecSupport::EnhancedNode#e!} (both of which wrap Nokogiri's `css` method).

Instead of creating another API for accessing HTML content, the Nokogiri API should be used directly.  You can create custom matchers
as needed for common assertions.  Brut includes a few that you will find useful:

* `have_link_to`
* `have_html_attribute`
* `have_i18n_string`


