import{_ as a,c as s,o as t,ag as i}from"./chunks/framework.1L-BeKqY.js";const u=JSON.parse('{"title":"Unit Tests","description":"","frontmatter":{},"headers":[],"relativePath":"unit-tests.md","filePath":"unit-tests.md"}'),n={name:"unit-tests.md"};function o(r,e,l,h,c,d){return t(),s("div",null,e[0]||(e[0]=[i(`<h1 id="unit-tests" tabindex="-1">Unit Tests <a class="header-anchor" href="#unit-tests" aria-label="Permalink to &quot;Unit Tests&quot;">​</a></h1><p>Tests in Brut use RSpec and given that most of your Brut-powered classes are simple Ruby classes, you can test them in conventional ways.</p><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>When you scaffold something like a page or component, Brut will create an empty test file in <code>specs/</code>, whose path mirrors the class in <code>app/src</code>. For example, <code>specs/front_end/handlers/login_handler.spec.rb</code> will test the class defined in <code>app/src/front_end/handlers/login_handler.rb</code>.</p><p>Each page of Brut&#39;s documentation includes a &quot;Testing&quot; section that outlines additional features avialable to make testing work more easily. This section will talk about general features and behavior.</p><h3 id="tests-run-in-a-database-transaction" tabindex="-1">Tests run in a Database Transaction <a class="header-anchor" href="#tests-run-in-a-database-transaction" aria-label="Permalink to &quot;Tests run in a Database Transaction&quot;">​</a></h3><p>At the start of each test (<code>it</code> block in RSpec), a database transaction is opened. At the end, the transaction is rolled back. This means that none of the changes you make to the database have any effect outside the context of the test.</p><p>The downside of this approach is that you cannot test anything that involves database transactions. For example, if you want to ensure that a piece of business logic runs inside a database transaction, you will have to assure that another way, such as spying.</p><h3 id="a-usable-requestcontext-is-created-for-front-end-tests" tabindex="-1">A Usable <code>RequestContext</code> is Created for Front End Tests <a class="header-anchor" href="#a-usable-requestcontext-is-created-for-front-end-tests" aria-label="Permalink to &quot;A Usable \`RequestContext\` is Created for Front End Tests&quot;">​</a></h3><p>Although your tests of pages, components, and handlers are generally isolated, it&#39;s possible to trigger codepaths where Brut will use <a href="/keyword-injection.html">keyword injection</a>, such as a global component.</p><p>To make sure this doesn&#39;t fail, Brut sets up a reasonable <code>RequestContext</code> that will be used for any such injections.</p><p>Brut will also <code>let</code> that instance, named <code>request_context</code>. This means you can access it and modify it in your test as needed. It will be recreated new for each test, so you are safe making changes to it.</p><h3 id="bin-test-audit-and-managing-tests" tabindex="-1"><code>bin/test audit</code> and Managing Tests <a class="header-anchor" href="#bin-test-audit-and-managing-tests" aria-label="Permalink to &quot;\`bin/test audit\` and Managing Tests&quot;">​</a></h3><p><code>bin/test audit</code> will fail if any file in <code>app/src</code> does not have a corresponding test. This is handy when you are moving fast to make sure you don&#39;t forget to add test coverage.</p><p>That said, sometimes classes are simple and won&#39;t benefit from a test, or a class&#39; behavior may be adequately covered by another test. It&#39;s helpful to record this information so it&#39;s clear that you&#39;ve given consideration to tests and not just forgotten them.</p><p>Every Brut test has <a href="/api/Brut/SpecSupport/GeneralSupport/ClassMethods.html" target="_self" rel="noopener" data-no-router><code>Brut::SpecSupport::GeneralSupport::ClassMethods</code></a> included and it provides three methods to help record your intent with respect to omitting tests. These methods should be called in a <code>describe</code> or <code>context</code> block.</p><ul><li><p><code>implementation_is_covered_by_other_tests(description)</code> used to explain where the coverage for this class is.</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RSpec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">describe</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TaxCalculator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> do</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  implementation_is_covered_by_other_tests </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;e2e tests for checkout&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div></li><li><p><code>implementation_is_needed(check_again_at:)</code> used when you want to acknowledge that a test is required, but for whatever reason you cannot provide it now. This will create a test that fails after the date/time given to <code>check_again_at:</code>.</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RSpec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">describe</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TaxCalculator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> do</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  implementation_is_needed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_again_at:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;2025-06-13&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div></li><li><p><code>implementation_is_trivial(check_again_at: nil)</code> used to indicate that code is trivial and would not benefit from the carrying cost of a test. <code>check_again_at:</code> is optional and this will create a failing test after that date. You&#39;d set this for a class that you suspect may grow in complexity, as a way to ensure it&#39;s not forgotten.</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RSpec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">describe</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TaxCalculator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> do</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  implementation_is_trivial</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div></li></ul><h2 id="recommended-practices" tabindex="-1">Recommended Practices <a class="header-anchor" href="#recommended-practices" aria-label="Permalink to &quot;Recommended Practices&quot;">​</a></h2><p>A list of recommended practices for testing could fill many books. Instead, we&#39;ll focus on a few things that will make life easier.</p><h3 id="go-easy-on-rspec-features" tabindex="-1">Go Easy on RSpec Features <a class="header-anchor" href="#go-easy-on-rspec-features" aria-label="Permalink to &quot;Go Easy on RSpec Features&quot;">​</a></h3><p>Shared contexts and shared examples usually make a test suite much harder to understand and much worse. You should avoid them entirely.</p><p><code>let</code> and <code>let!</code> also generally make things worse and should be avoided. It&#39;s usually better to have duplication in various <code>it</code> blocks than to try to parameterize the use of <code>let</code>. This is doubly true when you have nested contexts.</p><h3 id="custom-matchers-are-useful" tabindex="-1">Custom Matchers Are Useful <a class="header-anchor" href="#custom-matchers-are-useful" aria-label="Permalink to &quot;Custom Matchers Are Useful&quot;">​</a></h3><p>An effective way to re-use test assertions is via custom matchers. Brut makes use of these, and you can easily create your own. The recommended way to do this is:</p><ol><li>Create <code>specs/support/matchers</code></li><li>Create your matcher there, named for the matcher&#39;s method. For example, if your matcher is <code>be_active_account</code>, create <code>specs/support/matchers/be_active_account.rb</code>.</li><li>Implement your matcher per RSpec&#39;s instructions.</li><li>Use <code>require &quot;support/matchers/be_active_account&quot;</code> to require your matcher explicitly. This will make it easier to understand where everything is coming from when others read your test.</li><li>Check your matchers behavior with passing and failing tests and for negated versions. Ensure that <code>failure_message</code> and <code>failure_message_when_negated</code> produce useful messages.</li></ol><h3 id="lint-your-factories" tabindex="-1">Lint Your Factories <a class="header-anchor" href="#lint-your-factories" aria-label="Permalink to &quot;Lint Your Factories&quot;">​</a></h3><p>By default, your Brut app should come with a spec to verify that all your Factory Bot factories work:</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># specs/lint_factories.spec.rb</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">require</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;spec_helper&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RSpec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">describe</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;factories&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> do</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  it </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;should be possible to create them all&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> do</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    FactoryBot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lint</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> traits:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>This implies that each factory and each trait of that factory can be created without providing any additional attributes. This is <em>critical</em> to sustainable tests over time. If any factory can be created at any time without dependencies, your tests will be easy to write and maintain.</p><h2 id="technical-notes" tabindex="-1">Technical Notes <a class="header-anchor" href="#technical-notes" aria-label="Permalink to &quot;Technical Notes&quot;">​</a></h2><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p>Technical Notes are for deeper understanding and debugging. While we will try to keep them up-to-date with changes to Brut&#39;s internals, the source code is always more correct.</p></div><p><em>Last Updated May 9, 2025</em></p>`,32)]))}const k=a(n,[["render",o]]);export{u as __pageData,k as default};
