import{_ as e,c as t,o as s,ag as i}from"./chunks/framework.1L-BeKqY.js";const c=JSON.parse('{"title":"Why Does Brut Exist?","description":"","frontmatter":{},"headers":[],"relativePath":"why.md","filePath":"why.md"}'),o={name:"why.md"};function r(n,a,l,d,h,u){return s(),t("div",null,a[0]||(a[0]=[i('<h1 id="why-does-brut-exist" tabindex="-1">Why Does Brut Exist? <a class="header-anchor" href="#why-does-brut-exist" aria-label="Permalink to &quot;Why Does Brut Exist?&quot;">​</a></h1><p>I love writing Ruby, but grew tired of writing Rails. Rails is great, and has been great to me over the years. I&#39;ve written a lot of books about it! But the churn and increasing configuration burden made me think: what if we had another way to build web apps in Ruby?</p><p>I wanted something I felt was as easy and simple as Rails, but more accessible, more obvious, and with fewer abstractions and DSLs. Ruby and the web platform have come a long way in the last several years and the community has created a lot of great gems that can be used for a web framework.</p><p>My hope is that Brut can be a real alternative to Rails when creating web apps with Ruby. It doesn&#39;t need to be used by big huge companies. It probably shouldn&#39;t be! It doesn&#39;t need to take you to an IPO. But, it should allow building real, useful web apps using a great programming language!</p><h2 id="brut-is-not-rails" tabindex="-1">Brut is Not Rails <a class="header-anchor" href="#brut-is-not-rails" aria-label="Permalink to &quot;Brut is Not Rails&quot;">​</a></h2><p>There&#39;s a lot of lessons in app design and framework design in Rails. Brut definitely takes some of the good ideas, but I started from scratch (ish) and created abstractions only to solve a problem. That&#39;s why there&#39;s no controllers, no convoluted routing system, and no YAML.</p><h2 id="brut-is-not-hanami" tabindex="-1">Brut is Not Hanami <a class="header-anchor" href="#brut-is-not-hanami" aria-label="Permalink to &quot;Brut is Not Hanami&quot;">​</a></h2><p>Hanami has a lot of polish and great people working on it. But it&#39;s not designed the way I wanted to work. I find the DRY family of gems way too complicated for my taste, and Hanami just felt overall too complex. I&#39;m sure there&#39;s a reason it is the way it is, but it wasn&#39;t for me.</p><h2 id="brut-is-only-coincidentally-sinatra" tabindex="-1">Brut is Only Coincidentally Sinatra <a class="header-anchor" href="#brut-is-only-coincidentally-sinatra" aria-label="Permalink to &quot;Brut is Only Coincidentally Sinatra&quot;">​</a></h2><p>Brut is built on Sinatra, however it&#39;s treated as a private implementation detail. It was just the easiest way to bootstrap everything. Brut will never be as low level and flexible as Sinatra.</p><h2 id="brut-is-rack-the-web-and-as-straightforward-as-possible" tabindex="-1">Brut is Rack, The Web, and as Straightforward as Possible <a class="header-anchor" href="#brut-is-rack-the-web-and-as-straightforward-as-possible" aria-label="Permalink to &quot;Brut is Rack, The Web, and as Straightforward as Possible&quot;">​</a></h2><p>Rack is great. The Web is great. I tried to create abstractions only when needed and to mirror existing abstractions as close as possible. It&#39;s a small thing, but I have grown tired of typing <code>text_area</code> in Rails ERB files. It&#39;s <code>textarea</code>, or at least it should be.</p><p>My thinking is that you already need to know the web platform, HTML, CSS, SQL, and the basics of HTTP. Why learn an abstraction over those as well?</p><p>But I also didn&#39;t want to make everything myself. Sequel is a great library! Phlex is a great way to generate HTML! RSpec is a great testing library!</p>',14)]))}const p=e(o,[["render",r]]);export{c as __pageData,p as default};
