import{_ as a,c as s,o as t,ag as i}from"./chunks/framework.1L-BeKqY.js";const u=JSON.parse('{"title":"Routes","description":"","frontmatter":{},"headers":[],"relativePath":"routes.md","filePath":"routes.md"}'),o={name:"routes.md"};function n(r,e,l,h,d,p){return t(),s("div",null,e[0]||(e[0]=[i(`<h1 id="routes" tabindex="-1">Routes <a class="header-anchor" href="#routes" aria-label="Permalink to &quot;Routes&quot;">​</a></h1><p>The primary function of a web framework like Brut is to map URLs requested by the browser or an HTTP client and invoke code based on them.</p><p>Brut has a fairly simple routing system. It&#39;s not desgined to be flexible—it&#39;s designed to make the most common cases you will need as straigthforward as possible.</p><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><h3 id="route-syntax" tabindex="-1">Route Syntax <a class="header-anchor" href="#route-syntax" aria-label="Permalink to &quot;Route Syntax&quot;">​</a></h3><p>A route is a string that contains the path part of a <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL" target="_blank" rel="noreferrer">URL</a>. <em>Segments</em> of the path (i.e. the stuff between each forward slash <code>/</code>) can be either <em>static</em> or a <em>placeholder</em>. The route is given as a parameter to a method that indicates the purpose of the route (e.g. <code>page</code>), and these two factors determine the name of the class that will handle requests to that route.</p><p>Specifically:</p><ul><li>Only the <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL/pathname" target="_blank" rel="noreferrer">pathname</a> of a request may be specified.</li><li>All routes must start with a slash</li><li>The segements of the pathname may be static or placeholders. Placeholders must be a valid Ruby keyword argument prepended with a colon.</li><li>Routes may not start with a placeholder.</li></ul><p>Some examples:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;/dash_board&quot;</span></span>
<span class="line"><span>&quot;/widgets/:id&quot;</span></span>
<span class="line"><span>&quot;/company/:company_id/locations/:location_id&quot;</span></span>
<span class="line"><span>&quot;/&quot;</span></span></code></pre></div><h3 id="specifying-routes" tabindex="-1">Specifying Routes <a class="header-anchor" href="#specifying-routes" aria-label="Permalink to &quot;Specifying Routes&quot;">​</a></h3><p>As mentioned above, routes are passed to methods that determine their purpose. There are currently four types of routes, and thus four possible methods you would use to configure them:</p><table tabindex="0"><thead><tr><th>Method</th><th>Purpose</th><th>HTTP Method</th><th>More Info</th></tr></thead><tbody><tr><td><code>page</code></td><td>Specifies a web page at that route</td><td><code>GET</code></td><td><a href="/pages.html">Pages</a></td></tr><tr><td><code>form</code></td><td>Indicates a form will exist and post its form data to this route</td><td><code>POST</code></td><td><a href="/pages.html">Forms</a></td></tr><tr><td><code>action</code></td><td>Indicates a form with no form data will exist and post to this route</td><td><code>POST</code></td><td><a href="/handlers.html">Handlers</a></td></tr><tr><td><code>path</code></td><td>This route will respond to an arbitrary HTTP method, which must be specified as an additional parameter</td><td>Any</td><td><a href="/handlers.html">Handlers</a></td></tr></tbody></table><p>Brut is designed around generating HTML. HTML provides the ability to navigate to new web pages via <code>GET</code>, or submit data to the server from a <code>&lt;form&gt;</code> via <code>POST</code>. That is why three of the four methods are focused on these use-cases.</p><p>To specify routes, you can call these methods inside the <code>routes do</code> block of your <code>App</code> class, located in <code>app/src/app.rb</code>:</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> App</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Brut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Framework</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">App</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">           =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;my-app&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> organization</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;my-org&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span></span>
<span class="line highlighted"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    page   </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/widgets/:id&quot;</span></span>
<span class="line highlighted"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    form   </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/new_widget&quot;</span></span>
<span class="line highlighted"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    action </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/archive_widget/:id&quot;</span></span>
<span class="line highlighted"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    path   </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/widget_payment_received&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">method:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :put</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>Brut does not use an abstraction like resources to manage the routes of your web app. Few non-programmers know what a resource is, so the routing API is designed to match concepts a non-programmer can observe or identify, like URLs, forms, and pages.</p></div><h3 id="connecting-routes-to-code" tabindex="-1">Connecting Routes to Code <a class="header-anchor" href="#connecting-routes-to-code" aria-label="Permalink to &quot;Connecting Routes to Code&quot;">​</a></h3><p>Brut is convention-based, so the routes you specify, and the method you pass them to, determine the class that will handle the request. For <code>page</code> routes, Brut will locate a page class (see <a href="/pages.html">Pages</a>), which will be used to render the web page. All other routes will be managed by a handler (see <a href="/handlers.html">Handlers</a>), which are somewhat like a controller in Rails, but with only a single method.</p><p>The name of the class is determined as follows:</p><ul><li>Static segments of the pathname are mapped to namespaces or a class based on converting the path segment to camel-case. For example <code>new_widget</code> becomes <code>NewWidget</code>.</li><li>The final static segment in the path represents a class name. All other static segments represent modules in which the final class is namespaced <ul><li>If the route is for a page, <code>Page</code> is appended to the class name.</li><li>If the route is for a form, there are two classes in play, one appended with <code>Form</code> and one with <code>Handler</code>.</li><li>If the route has no form and is just a handler, <code>Handler</code> is appended to the class name.</li></ul></li><li>Placeholder segments are attached to the previous static segment, augmenting its name: <ul><li>The placeholder is camel-cased</li><li>The placeholder is prefixed with <code>By</code> for <code>page</code> routes and <code>With</code> for all other routes</li><li>the prefixed-placeholder is appended to the previous module or class name, e.g. <code>WidgetsById</code></li></ul></li><li>These are now connected to form a valid Ruby class name.</li><li>The route <code>/</code> is special and always maps to <code>HomePage</code>.</li></ul><p>The examples in the previous section demonstrate how this works:</p><table tabindex="0"><thead><tr><th>Route</th><th>Class name</th></tr></thead><tbody><tr><td><code>page &quot;/widgets/:id&quot;</code></td><td><code>WidgetsByIdPage</code></td></tr><tr><td><code>form &quot;/new_widget&quot;</code></td><td><code>NewWidgetForm</code> and <code>NewWidgetHandler</code></td></tr><tr><td><code>action &quot;/archive_widget/:id&quot;</code></td><td><code>ArchiveWidgetByIdHandler</code></td></tr><tr><td><code>path &quot;/widget_payment_received&quot;, method: :put</code></td><td><code>WidgetPaymentReceivedHandler</code></td></tr></tbody></table><p>Note that deeply nested routes that contain several placeholders will work, and create complicated classnames.</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">page </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/company/:company_id/location/:location_id&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># =&gt; CompanyByCompanyId::LocationByLocationIdPage</span></span></code></pre></div><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>If you don&#39;t like long complicated names, deeply-nested namespaces, and long directory names, name your routes accordingly.</p></div><h3 id="creating-uris-from-routes" tabindex="-1">Creating URIs from Routes <a class="header-anchor" href="#creating-uris-from-routes" aria-label="Permalink to &quot;Creating URIs from Routes&quot;">​</a></h3><p>Because each route is associated with a class, you can use the class to create the route, including any placeholders and query string parameters.</p><p>The most direct way to do this is with the <code>routing</code> method available on each page or handler class:</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> WidgetsByIdPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">id:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># =&gt; /widgets/42</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> WidgetsByIdPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">id:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compact:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># =&gt; /widgets/42?compact=true</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ArchiveWidgetByIdHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">id:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># =&gt; /archive_widget/42</span></span></code></pre></div><p>If you fail to provide the required parameters, <code>routing</code> will raise a <a href="/api/Brut/Framework/Errors/MissingParameter.html" target="_self" rel="noopener" data-no-router><code>Brut::Framework::Errors::MissingParameter</code></a> with a message explaining the problem.</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> begin</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    WidgetsByIdPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  rescue</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Brut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Framework</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Errors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MissingParameter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> =&gt; ex</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    puts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">message</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  end</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># =&gt; Parameter &#39;id&#39; was not available. Received params: no params.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#    :id was used as a path parameter for</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#    WidgetsByIdPage (path &#39;/widgets/:id&#39;)</span></span></code></pre></div><p><code>routing</code> is how you create links to other pages:</p><div class="language-erb vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">erb</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">a</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&lt;%= </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DashBoardPage</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> %&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Go to Dashboard</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>You can use <code>routing</code> to create <code>&lt;form&gt;</code> actions, but <code>form_tag</code>, which we&#39;ll discuss in <a href="/forms.html">Forms</a>, can do this for you.</p></div><p>The <code>routing</code> method isn&#39;t an abstraction around routes. It&#39;s more of a strongly-typed translation. This means when you change something, your app won&#39;t route to non-existent routes—it&#39;ll blow up with a helpful error.</p><p>For example, if you decided that <code>/dash_board/</code> should&#39;ve been called <code>/account_home</code>, you would change the value in <code>app.rb</code>, then rename the class. At this point, any code that routes to <code>DashboardPage.routing</code> will raise a <code>NameError</code>. With sufficient test coverage, you can address everywhere you see the <code>NameError</code> and be confident you have changed the name and route successfully.</p><h2 id="testing" tabindex="-1">Testing <a class="header-anchor" href="#testing" aria-label="Permalink to &quot;Testing&quot;">​</a></h2><p>Routes are configuration, so you do not need to test them. Your end-to-end tests will ensure your links and form actions are working, and your page tests will ensure any routes they generate in HTML are valid.</p><h2 id="recommended-practices" tabindex="-1">Recommended Practices <a class="header-anchor" href="#recommended-practices" aria-label="Permalink to &quot;Recommended Practices&quot;">​</a></h2><p>Brut does not provide flexibility with routes. For example, you cannot specify an optional placeholder. While this may change, Brut is designed to isolate logic to classes like pages, forms, hooks, middlewares, or handlers. Brut does not want logic to exist at the routing layer.</p><p>Beyond these technical limitations, here are some recommendations regarding routes.</p><h3 id="routes-should-be-named-for-concepts-anyone-can-understand" tabindex="-1">Routes Should be Named for Concepts Anyone Can Understand <a class="header-anchor" href="#routes-should-be-named-for-concepts-anyone-can-understand" aria-label="Permalink to &quot;Routes Should be Named for Concepts Anyone Can Understand&quot;">​</a></h3><p>You don&#39;t need your routes to be the names of models or database tables. If you have an account management page that allows modifying data in a table called <code>user_preferences</code>, but everyone just calls it &quot;the account management page&quot;, the route should be <code>/account_management</code>.</p><p>Although routes are primarily for programmers to manage, there&#39;s no reason not to name them using the terms everyone involved in your app uses. This is part of the reason Brut inserts <code>By</code> or <code>With</code> when there is a placeholder. It allows you to have a page for all widgets—the &quot;widgets page&quot;—and a page for a specific widget by id—the &quot;widgets by id page&quot;.</p><h3 id="prefer-shallow-routes-with-a-single-placeholder" tabindex="-1">Prefer Shallow Routes with a Single Placeholder <a class="header-anchor" href="#prefer-shallow-routes-with-a-single-placeholder" aria-label="Permalink to &quot;Prefer Shallow Routes with a Single Placeholder&quot;">​</a></h3><p>The more path segments your route has, and the more placeholders it is, the longer your class name will be and the more you lose the connection to reality. The &quot;company by company id location by location id page&quot; doesn&#39;t exactly roll off the tongue.</p><p>Life will be easier if you can choose names and routes that have a single placeholder. Multiple path segments can be useful for namespacing.</p><h3 id="placeholders-identify-things-query-strings-search-for-things" tabindex="-1">Placeholders Identify Things, Query Strings Search for Things <a class="header-anchor" href="#placeholders-identify-things-query-strings-search-for-things" aria-label="Permalink to &quot;Placeholders Identify Things, Query Strings Search for Things&quot;">​</a></h3><p>You could certainly have a <code>/widgets</code> route, and then look at a query string parameter named <code>id</code> to know what widget to show. This is likely not what you want. If a route should always identify a specific thing in your back-end, it should have a placeholder where that thing&#39;s identifier goes.</p><p>If a route allows searching for things with multiple optional critiera, a query string is more appropriate. This is the HTTP spec, so if you follow its guidelines, you&#39;ll be fine.</p><h3 id="pluralization-is-up-to-you" tabindex="-1">Pluralization Is Up to You <a class="header-anchor" href="#pluralization-is-up-to-you" aria-label="Permalink to &quot;Pluralization Is Up to You&quot;">​</a></h3><p>The rules Brut uses to determine the class names to handle routes do not rely on pluralization. You can have a <code>/widget</code> route and a <code>/widgets</code> route, if that makes sense to your domain and team. They are both handled by the same set of underlying rules.</p><h2 id="technical-notes" tabindex="-1">Technical Notes <a class="header-anchor" href="#technical-notes" aria-label="Permalink to &quot;Technical Notes&quot;">​</a></h2><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p>Technical Notes are for deeper understanding and debugging. While we will try to keep them up-to-date with changes to Brut&#39;s internals, the source code is always more correct.</p></div><p><em>Last Updated Feb 23, 2025</em></p><p>Brut stores all configured routes in a <a href="/api/Brut/FrontEnd/Routing.html" target="_self" rel="noopener" data-no-router><code>Brut::FrontEnd::Routing</code></a> object. This means that all metadata about a route is available. You are not intended to interact with this class, but you will note that in certain circumstances, the <a href="/api/Brut/FrontEnd/Routing/Route.html" target="_self" rel="noopener" data-no-router><code>Brut::FrontEnd::Routing::Route</code></a> can be injected into your class.</p><p>Brut uses this metadata to create route handlers with Sinatra. While Brut may not always use Sinatra under the covers, it does as of the writing, so when you call <code>page &quot;/widgets&quot;</code>, Brut will call <code>get &quot;/widgets&quot; do</code> and pass a block to Sinatra to find the class to handle the reqest, create an instance of it, call a method on it, and return the response.</p>`,58)]))}const g=a(o,[["render",n]]);export{u as __pageData,g as default};
