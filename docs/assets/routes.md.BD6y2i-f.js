import{_ as a,c as t,o as s,ag as i}from"./chunks/framework.1L-BeKqY.js";const u=JSON.parse('{"title":"Routes","description":"","frontmatter":{},"headers":[],"relativePath":"routes.md","filePath":"routes.md"}'),o={name:"routes.md"};function n(r,e,l,h,d,p){return s(),t("div",null,e[0]||(e[0]=[i(`<h1 id="routes" tabindex="-1">Routes <a class="header-anchor" href="#routes" aria-label="Permalink to &quot;Routes&quot;">​</a></h1><p>The primary function of a web framework like Brut is to map URLs requested by the browser or an HTTP client and invoke code based on them.</p><p>Brut has a fairly simple routing system that&#39;s not designed for flexibility.</p><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>Your app has a subclass of <a href="/api/Brut/Framework/App.html" target="_self" rel="noopener" data-no-router><code>Brut::Framework::App</code></a>, called <code>App</code>. It includes a call to the <code>routes</code> class method. In there, you declare your routes by using one of four methods:</p><table tabindex="0"><thead><tr><th>Method</th><th>HTTP Method</th><th>Purpose</th></tr></thead><tbody><tr><td><code>page «route»</code></td><td>GET</td><td>Declare a page</td></tr><tr><td><code>form «route»</code></td><td>POST</td><td>Declare a form to be submitted to a handler</td></tr><tr><td><code>action «route»</code></td><td>POST</td><td>Declare an element-less form to be submitted to a handler (akin to Rails&#39; <code>button_to</code> helper)</td></tr><tr><td><code>path «route», method: «method»</code></td><td><code>«method»</code></td><td>Declare an arbitrary path to a handler</td></tr></tbody></table><p>The value for <code>«route»</code>, along with the method called, is used to determine what class(es) will be used to handle the route.</p><h3 id="«route»-syntax" tabindex="-1">«route» Syntax <a class="header-anchor" href="#«route»-syntax" aria-label="Permalink to &quot;«route» Syntax&quot;">​</a></h3><p>A route is a string that contains the <em>path part</em> of a <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL" target="_blank" rel="noreferrer">URL</a>. <em>Segments</em> of the path (i.e. the stuff between each forward slash <code>/</code>) can be either <em>static</em> or a <em>placeholder</em>.</p><p>As such:</p><ul><li>Only the <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL/pathname" target="_blank" rel="noreferrer">pathname</a> of a request may be specified.</li><li>All routes must start with a slash</li><li>A placeholder segment must be a valid Ruby identifier preceded by a colon, e.g. <code>:company_id</code> is allowed, but <code>:company-id</code> is not.</li><li>Routes may not start with a placeholder.</li></ul><p>Some examples:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;/dash_board&quot;</span></span>
<span class="line"><span>&quot;/widgets/:id&quot;</span></span>
<span class="line"><span>&quot;/company/:company_id/locations/:location_id&quot;</span></span>
<span class="line"><span>&quot;/&quot;</span></span></code></pre></div><h3 id="class-naming-conventions" tabindex="-1">Class Naming Conventions <a class="header-anchor" href="#class-naming-conventions" aria-label="Permalink to &quot;Class Naming Conventions&quot;">​</a></h3><p>Brut is convention-based, so you are not able to specify the name of the classes used to handle routes. Brut will use the method you called (e.g. <code>page</code>) and the route your provided to determine the class name.</p><p>Some examples:</p><table tabindex="0"><thead><tr><th>Route invocation</th><th>Expected Class Name(s)</th></tr></thead><tbody><tr><td><code>page &quot;/dashboard&quot;</code></td><td><code>DashboardPage</code></td></tr><tr><td><code>page &quot;/widgets/:id&quot;</code></td><td><code>WidgetsByIdPage</code></td></tr><tr><td><code>form &quot;/login&quot;</code></td><td><code>LoginForm</code> and <code>LoginHandler</code></td></tr><tr><td><code>action &quot;/delete_widget/:id&quot;</code></td><td><code>DeleteWidgetWithIdHandler</code></td></tr><tr><td><code>path &quot;/tokens/personal/:token, method :put&quot;</code></td><td><code>Tokens::PersonalWithTokenHandler</code></td></tr></tbody></table><p>Specifically, the name of the class(es) is/are determined as follows:</p><ul><li>Static segments of the pathname are mapped to namespaces or a class based on converting the path segment to camel-case. For example <code>new_widget</code> becomes <code>NewWidget</code>.</li><li>The final static segment in the path represents a class name. All other static segments represent modules in which the final class is namespaced <ul><li>If the route is for a page, <code>Page</code> is appended to the class name.</li><li>If the route is for a form, there are two classes in play, one appended with <code>Form</code> and one with <code>Handler</code>.</li><li>If the route has no form and is just a handler, <code>Handler</code> is appended to the class name.</li></ul></li><li>Placeholder segments are attached to the previous static segment, augmenting its name: <ul><li>The placeholder is camel-cased</li><li>The placeholder is prefixed with <code>By</code> for <code>page</code> routes and <code>With</code> for all other routes</li><li>the prefixed-placeholder is appended to the previous module or class name, e.g. <code>WidgetsById</code></li></ul></li><li>These are now connected to form a valid Ruby class name.</li><li>The route <code>/</code> is special and always maps to <code>HomePage</code>.</li></ul><p>Note that deeply nested routes that contain several placeholders will work, and create complicated classnames.</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">page </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/company/:company_id/location/:location_id&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># =&gt; CompanyByCompanyId::LocationByLocationIdPage</span></span></code></pre></div><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>All routes can receive query string parameters. These are not factored into the name of the class that will handle the route, but they <em>are</em> made available to your Page or Handler.</p></div><h3 id="creating-uris-for-routes" tabindex="-1">Creating URIs for Routes <a class="header-anchor" href="#creating-uris-for-routes" aria-label="Permalink to &quot;Creating URIs for Routes&quot;">​</a></h3><p>Because each route is associated with a class, you can use the class to create the route, including any placeholders and query string parameters.</p><p>The most direct way to do this is with the <code>routing</code> method available on each page or handler class:</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> WidgetsByIdPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">id:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># =&gt; /widgets/42</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> WidgetsByIdPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">id:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compact:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># =&gt; /widgets/42?compact=true</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> WidgetsByIdPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">id:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compact:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">anchor:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;summary&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># =&gt; /widgets/42?compact=true#summary</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ArchiveWidgetByIdHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">id:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># =&gt; /archive_widget/42</span></span></code></pre></div><p>If you fail to provide the required parameters, <code>routing</code> will raise a <a href="/api/Brut/Framework/Errors/MissingParameter.html" target="_self" rel="noopener" data-no-router><code>Brut::Framework::Errors::MissingParameter</code></a> with a message explaining the problem.</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> begin</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    WidgetsByIdPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  rescue</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Brut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Framework</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Errors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MissingParameter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> =&gt; ex</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    puts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">message</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  end</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># =&gt; Parameter &#39;id&#39; was not available. Received params: no params.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#    :id was used as a path parameter for</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#    WidgetsByIdPage (path &#39;/widgets/:id&#39;)</span></span></code></pre></div><p><code>routing</code> is how you create links to other pages:</p><div class="language-erb vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">erb</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">a</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&lt;%= </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DashBoardPage</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> %&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Go to Dashboard</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>You can use <code>routing</code> to create <code>&lt;form&gt;</code> actions, but <a href="/api/Brut/FrontEnd/Components/FormTag.html" target="_self" rel="noopener" data-no-router><code>Brut::FrontEnd::Components::FormTag</code></a>, which we&#39;ll discuss in <a href="/forms.html">Forms</a>, can do this for you.</p></div><p>The <code>routing</code> method isn&#39;t an abstraction around routes. It&#39;s more of a strongly-typed translation. This means when you change something, your app won&#39;t route to non-existent routes—it&#39;ll blow up with a helpful error.</p><p>For example, if you decided that <code>/dash_board/</code> should&#39;ve been called <code>/account_home</code>, you would change the value in <code>app.rb</code>, then rename the class. At this point, any code that routes to <code>DashboardPage.routing</code> will raise a <code>NameError</code>. With sufficient test coverage, you can address everywhere you see the <code>NameError</code> and be confident you have changed the name and route successfully.</p><h2 id="testing" tabindex="-1">Testing <a class="header-anchor" href="#testing" aria-label="Permalink to &quot;Testing&quot;">​</a></h2><p>Routes are configuration, so you do not need to test them. In fact, you can&#39;t test them directly. Your end-to-end tests should adequately cover the correct usage of your routes. If you always using <code>.routing</code> to generate routes, Ruby&#39;s runtime checks will also ensure you have not used a non-existent or invalid route.</p><h2 id="recommended-practices" tabindex="-1">Recommended Practices <a class="header-anchor" href="#recommended-practices" aria-label="Permalink to &quot;Recommended Practices&quot;">​</a></h2><p>Brut does not provide flexibility with routes, nor is logic intended to exist where you are declaring them.</p><h3 id="routes-should-be-named-for-concepts-anyone-can-understand" tabindex="-1">Routes Should be Named for Concepts Anyone Can Understand <a class="header-anchor" href="#routes-should-be-named-for-concepts-anyone-can-understand" aria-label="Permalink to &quot;Routes Should be Named for Concepts Anyone Can Understand&quot;">​</a></h3><p>If you have an account management page that allows modifying data in a table called <code>user_preferences</code>, but everyone just calls it &quot;the account management page&quot;, the route should be <code>/account_management</code>.</p><p>Although routes are primarily for programmers, there&#39;s no reason not to name them using the terms everyone involved in your app uses. This is part of the reason Brut inserts <code>By</code> or <code>With</code> when there is a placeholder. It allows you to have a page for all widgets—the &quot;widgets page&quot;—and a page for a specific widget by id—the &quot;widgets by id page&quot;.</p><h3 id="prefer-shallow-routes-with-a-single-placeholder" tabindex="-1">Prefer Shallow Routes with a Single Placeholder <a class="header-anchor" href="#prefer-shallow-routes-with-a-single-placeholder" aria-label="Permalink to &quot;Prefer Shallow Routes with a Single Placeholder&quot;">​</a></h3><p>The more path segments your route has, and the more placeholders it is, the longer your class name will be and the more you lose the connection to reality. The &quot;company by company id location by location id page&quot; doesn&#39;t exactly roll off the tongue.</p><p>Life will be easier if you can choose names and routes that have a single placeholder. Multiple path segments can be useful for namespacing.</p><h3 id="placeholders-identify-things-query-strings-search-for-things" tabindex="-1">Placeholders Identify Things, Query Strings Search for Things <a class="header-anchor" href="#placeholders-identify-things-query-strings-search-for-things" aria-label="Permalink to &quot;Placeholders Identify Things, Query Strings Search for Things&quot;">​</a></h3><p>A query string is for just that: querying. The query string is not for identifying things. That&#39;s what URIs are for.</p><p>As such, for routes where a specific <em>thing</em> is being identified, use route placeholders like <code>/widgets/:id</code>. When a route is used for searching or locating <em>things</em>, a query string is better: <code>/widgets?type=«type»</code>.</p><p>Remember that the query string is <em>not</em> part of the class name. The values for the query string will be made available to your page or handler.</p><h3 id="pluralization-is-up-to-you" tabindex="-1">Pluralization Is Up to You <a class="header-anchor" href="#pluralization-is-up-to-you" aria-label="Permalink to &quot;Pluralization Is Up to You&quot;">​</a></h3><p>The rules Brut uses to determine the class names to handle routes do not rely on pluralization. You can have a <code>/widget</code> route and a <code>/widgets</code> route, if that makes sense to your domain and team. They are both handled by the same set of underlying rules.</p><h2 id="technical-notes" tabindex="-1">Technical Notes <a class="header-anchor" href="#technical-notes" aria-label="Permalink to &quot;Technical Notes&quot;">​</a></h2><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p>Technical Notes are for deeper understanding and debugging. While we will try to keep them up-to-date with changes to Brut&#39;s internals, the source code is always more correct.</p></div><p><em>Last Updated Feb 23, 2025</em></p><p>Brut stores all configured routes in a <a href="/api/Brut/FrontEnd/Routing.html" target="_self" rel="noopener" data-no-router><code>Brut::FrontEnd::Routing</code></a> object. This means that all metadata about a route is available. You are not intended to interact with this class, but you will note that in certain circumstances, the <a href="/api/Brut/FrontEnd/Routing/Route.html" target="_self" rel="noopener" data-no-router><code>Brut::FrontEnd::Routing::Route</code></a> can be injected into your class.</p><p>Brut uses this metadata to create route handlers with Sinatra. While Brut may not always use Sinatra under the covers, it does as of the writing, so when you call <code>page &quot;/widgets&quot;</code>, Brut will call <code>get &quot;/widgets&quot; do</code> and pass a block to Sinatra to find the class to handle the reqest, create an instance of it, call a method on it, and return the response.</p>`,54)]))}const g=a(o,[["render",n]]);export{u as __pageData,g as default};
