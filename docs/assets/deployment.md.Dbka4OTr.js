import{_ as t,c as o,o as a,ag as i}from"./chunks/framework.1L-BeKqY.js";const u=JSON.parse('{"title":"Deployment","description":"","frontmatter":{},"headers":[],"relativePath":"deployment.md","filePath":"deployment.md"}'),n={name:"deployment.md"};function s(r,e,l,d,c,p){return a(),o("div",null,e[0]||(e[0]=[i('<h1 id="deployment" tabindex="-1">Deployment <a class="header-anchor" href="#deployment" aria-label="Permalink to &quot;Deployment&quot;">​</a></h1><p>Brut apps are Rack apps, so they can be deployed in conventional ways. Brut apps are 12-factor apps and the scripts used for development are inteded to work for production as well.</p><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>Everyone deploys apps in different ways. Brut can&#39;t provide a simple solution for all deployment setups, so this document will outline considerations when setting up deployment.</p><p>The most direct way to understand what needs to happen is to look at <code>deploy/Dockerfile</code>, which is the foundation of a <code>Dockerfile</code> you can use. In particular, it shows you the commands needed to setup and run the app in production:</p><p>Beyond installing system software to run any Ruby web app, as well as whatever is needed for NodeJS and Postgres, the Brut-specific parts look like so:</p><ol><li>Install Ruby Gems with <code>bundle install</code></li><li>Install Node modules with <code>npm clean-install</code></li><li>Build all assets with <code>bin/build-assets</code> (this will bundle all CSS and Javascript, plus copy over any other <a href="/assets.html">assets</a> to the locations from where the Brut app will serve them)</li><li>Run the app with <code>bin/run</code></li></ol><p>Your Brut app also includes <code>bin/release</code> which is a script intended to run in the production environment after the code has been deployed, but before the app starts up. By default, it applies any needed migrations to the database.</p><h2 id="testing" tabindex="-1">Testing <a class="header-anchor" href="#testing" aria-label="Permalink to &quot;Testing&quot;">​</a></h2><p>If you are using Docker, you can create the <code>Dockerfile</code>s and run them locally to see how they work. You will need to have local versions of all infrastructure (database, Redis, etc.), but if these work locally, there is a high chance they work in production.</p><p>If you are not using Docker, you will need to apply various techniques that are beyond the scope of this documentation.</p><h2 id="recommended-practices" tabindex="-1">Recommended Practices <a class="header-anchor" href="#recommended-practices" aria-label="Permalink to &quot;Recommended Practices&quot;">​</a></h2><p>Brut goes to great lengths to avoid environment-specific code. Much of Brut&#39;s behavior works the same in dev as it does in production. For example, assets are hashed in all environments.</p><p>Assuming your code does the same thing, there should be a minium of surprises. That all being said, here are some recommendations:</p><ul><li>Create a way to interact with external services in a testing capacity. For example, ensure you have a test user with a known email address and trigger an email to them. Or a company credit card you charge and refund.</li><li>Configure observability so you know what your app is doing at all times.</li><li>Configure a URL that, when accessed, produces an error. This allows you to check your error reporting system.</li><li>Create a page somewhere that shows the git SHA of your deployment, or some other unique, unambiguous version number. This will clarify what version of the code is actually running.</li></ul>',15)]))}const m=t(n,[["render",s]]);export{u as __pageData,m as default};
