import{_ as o,c as a,o as s,ag as t}from"./chunks/framework.1L-BeKqY.js";const m=JSON.parse('{"title":"Business or Domain Logic","description":"","frontmatter":{},"headers":[],"relativePath":"business-logic.md","filePath":"business-logic.md"}'),n={name:"business-logic.md"};function i(c,e,r,d,l,u){return s(),a("div",null,e[0]||(e[0]=[t('<h1 id="business-or-domain-logic" tabindex="-1">Business or Domain Logic <a class="header-anchor" href="#business-or-domain-logic" aria-label="Permalink to &quot;Business or Domain Logic&quot;">​</a></h1><p>Since business and domain logic is not required, nor encouraged, to go in your data models, where does it go?</p><p>It can go anywhere you like - Brut is not currently prescriptive.</p><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>It&#39;s recommended that you place classes in <code>app/src/back_end</code>. Any directory created in there will be auto-loaded by Brut/Zeitwerk based on its rules. This means that classes in any directory in <code>app/src/back_end</code> should not be namespaced.</p><p>For example, if you have <em>commands</em> and <em>queries</em>, you may want them in <code>app/src/back_end/commands</code> and <code>app/src/back_end/queries</code>, respectively. In this case, <code>NewOrganizationCommand</code> would go in <code>app/src/back_end/commands/new_organization_command.rb</code> and <code>AccountQuery</code> would go in <code>app/src/back_end/queries/account_query.rb</code></p><p>Or, you could could organize them into <code>app/src/back_end/business_logic/commands</code> and <code>app/src/back_end/business_logic/queries</code>. In that case, <code>Commands::NewOrganization</code> would be expected in <code>app/src/back_end/business_logic/commands/new_organization.rb</code> and <code>Queries::Account</code> would be expected in <code>app/src/back_end/business_logic/queries/account.rb</code>.</p><p>How you organize it is up to you.</p><h2 id="testing" tabindex="-1">Testing <a class="header-anchor" href="#testing" aria-label="Permalink to &quot;Testing&quot;">​</a></h2><p>Tests can be written using RSpec in the usual way. Spec files should be in <code>specs/back_end/path/to/class.spec.rb</code>. Note that Brut expects Spec files to end in <code>.spec.rb</code> and <em>not</em><code>_spec.rb</code>.</p><p>There is nothing special about the tests for your domain logic. Write them however you need to.</p><h2 id="recomended-practices" tabindex="-1">Recomended Practices <a class="header-anchor" href="#recomended-practices" aria-label="Permalink to &quot;Recomended Practices&quot;">​</a></h2><p>This could be an entire series of books. The main recommendation is to take a light approach and don&#39;t immediately install complex frameworks or libraries unless you know you need them.</p><p>Something somewhere in your business logic will need to interface with your front-end. The simplest way to do that is to allow form objects to be passed into your back-end. The second simplest way is to pass form values into your back-end.</p><p>You are strongly discouraged from having your front-end locate data models and pass those to your back-end. This can be done while prototyping and for fast iteration on a concept, but generally you do not want to query your database from your handlers or pages just to pass the results into a back-end class.</p><p>Exposing data models to the front-end is generally OK, as that is sometimes what you need to do.</p><h2 id="technical-notes" tabindex="-1">Technical Notes <a class="header-anchor" href="#technical-notes" aria-label="Permalink to &quot;Technical Notes&quot;">​</a></h2><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p>Technical Notes are for deeper understanding and debugging. While we will try to keep them up-to-date with changes to Brut&#39;s internals, the source code is always more correct.</p></div><p><em>Last Updated May 7, 2025</em></p><p>Creating universal abstractions from business logic is difficult. Brut is unlikely to do this. If it does, it will be after much analysis of exsiting patterns and <em>only</em> if it helps avoid mistakes and increases developer throughput.</p>',20)]))}const h=o(n,[["render",i]]);export{m as __pageData,h as default};
