import{_ as a,c as n,o as s,ag as o}from"./chunks/framework.C4nOkCZI.js";const h=JSON.parse('{"title":"Deployment","description":"","frontmatter":{},"headers":[],"relativePath":"deployment.md","filePath":"deployment.md"}'),t={name:"deployment.md"};function p(i,e,l,r,d,c){return s(),n("div",null,[...e[0]||(e[0]=[o(`<h1 id="deployment" tabindex="-1">Deployment <a class="header-anchor" href="#deployment" aria-label="Permalink to &quot;Deployment&quot;">​</a></h1><p>Brut apps are Rack apps, so they can be deployed in conventional ways.</p><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>There are just too many ways to deploy. Brut attempts to address this by adhering to <a href="https://12factor.net" target="_blank" rel="noreferrer">12-factor principles</a>. Brut also tries not to create artifacts like <code>Procfile</code> or <code>Dockerfile</code> that would conflict with the artifacts you&#39;d need to manage deployment.</p><p>That said, Brut includes first-class support for deploying to Heroku using containers. More options will be included as necessary, either through direct support in code/tooling, or documentation here.</p><h3 id="heroku-container-based-deployment" tabindex="-1">Heroku Container-based Deployment <a class="header-anchor" href="#heroku-container-based-deployment" aria-label="Permalink to &quot;Heroku Container-based Deployment&quot;">​</a></h3><p>When creating your Brut app with <code>mkbrut</code>, the Heroku segment can be used to create files and scripts for a <a href="https://devcenter.heroku.com/articles/container-registry-and-runtime" target="_blank" rel="noreferrer">Heroku container-based deployment</a>.</p><table tabindex="0"><thead><tr><th>File</th><th>Purpose</th><th>Notes</th></tr></thead><tbody><tr><td><code>bin/deploy</code></td><td>Script to use to perform the deployment</td><td>This wraps <code>HerokuContainerBasedDeploy</code> in <a href="/api/Brut/CLI/Apps.html" target="_self" rel="noopener" data-no-router><code>Brut::CLI::Apps</code></a></td></tr><tr><td><code>deploy/Dockerfile</code></td><td>Template <code>Dockerfile</code> used to create a <code>Dockerfile</code> for each process type</td><td>Heroku requires each process (web, worker, release, etc.) to have its own <code>Dockerfile</code> and own image</td></tr><tr><td><code>deploy/heroku_config.rb</code></td><td>Class that exports optional processes</td><td>By default, your app has a web and release process. <code>HerokuConfig</code> can export others, like Sidekiq</td></tr><tr><td><code>deploy/docker-entrypoint</code></td><td>The <a href="https://docs.docker.com/reference/dockerfile/#entrypoint" target="_blank" rel="noreferrer"><code>ENTRYPOINT</code></a> for production Docker images, which is set up to use jemalloc</td><td>You can modify or remove this as needed</td></tr></tbody></table><p>How to deploy:</p><ol><li><p>Get an auth token from Heroku, which you can do from inside the container, and save it to <code>bash_customizations.local</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>your-computer&gt; dx/exec bash</span></span>
<span class="line"><span>devcontainer&gt; heroku auth:login</span></span>
<span class="line"><span># You will need to copy/paste the URL to log in</span></span>
<span class="line"><span>devcontainer&gt; heroku authorizations:create -d &quot;container pushes&quot; --expires-in 31536000</span></span>
<span class="line"><span># Copy the token output by this command</span></span>
<span class="line"><span>devcontainer&gt; echo &quot;HEROKU_API_KEY=«TOKEN YOU COPIED»&quot; &gt;&gt; dx/bash_customizations.local</span></span></code></pre></div></li><li><p>Exit the devcontainer and stop <code>dx/start</code> (e.g. hit <code>Ctrl-C</code> wherever you ran it)</p></li><li><p>Rebuild and restart the devcontainer (this will set <code>HEROKU_API_KEY</code> for you)</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>your-computer&gt; dx/build</span></span>
<span class="line"><span>your-computer&gt; dx/start</span></span>
<span class="line"><span># In another terminal window</span></span>
<span class="line"><span>your-computer&gt; dx/exec bash</span></span>
<span class="line"><span>devcontainer&gt; echo $HEROKU_API_KEY</span></span>
<span class="line"><span># You should see the token</span></span></code></pre></div><p>Setting this environment variable avoids having to constantly re-authenticate to Heroku.</p></li><li><p>Create your app using the container stack:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&gt; heroku create --stack container -a «your heroku app name»</span></span></code></pre></div></li><li><p>Ensure your app&#39;s source code is all checked in, there are no uncommitted or unadded files, and you have pushed to the <code>main</code> branch of your remote Git repository.</p></li><li><p><code>bin/deploy</code></p><p>This will generate a <code>Dockerfile</code> for each process (by default, <code>Dockerfile.web</code> and <code>Dockerfile.release</code>), build images, push those images to Heroku, and ask Heroku to release them.</p></li></ol><p>Debugging Tips:</p><ul><li><p>Keep in mind it&#39;s hard to make general deployment tools. You are expected to understand your deployment and be capable of deploying an arbitrary Rack app manually. Brut&#39;s tooling automates what you need to do based on what you already need to know.</p></li><li><p><code>bin/deploy</code> runs the <code>deploy</code> subcommand, so <code>bin/deploy help deploy</code> can provide some options for debugging issues:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>devcontainer&gt; bin/deploy help deploy</span></span>
<span class="line"><span>Usage: bin/deploy [global options] deploy [command options] </span></span>
<span class="line"><span></span></span>
<span class="line"><span>    Build images, push them to Heroku, and deploy them</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    Manages a deploy process based on using Heroku&#39;s Container Registry. See</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    https://devcenter.heroku.com/articles/container-registry-and-runtime</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    for details. You are assumed to understand this.</span></span>
<span class="line"><span>    This command will make the process somewhat easier.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    This will use deploy/Dockerfile as a template to create</span></span>
<span class="line"><span>    one Dockerfile for each process you want to run in Heroku.</span></span>
<span class="line"><span>    deploy/heroku_config.rb is where the processes and their</span></span>
<span class="line"><span>    commands are configured.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    The release phase is included automatically, based on bin/release.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>GLOBAL OPTIONS</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    -h, --help            Get help</span></span>
<span class="line"><span>        --log-level=LEVEL Set log level. Allowed values: debug,</span></span>
<span class="line"><span>                          info, warn, error, fatal. Default &#39;fatal&#39;</span></span>
<span class="line"><span>        --verbose         Set log level to &#39;debug&#39;, which will produce</span></span>
<span class="line"><span>                          maximum output</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ENVIRONMENT VARIABLES</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    BRUT_CLI_RAISE_ON_ERROR - if set, shows backtrace on errors</span></span>
<span class="line"><span>    LOG_LEVEL               - log level if --log-level or --verbose is omitted</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>COMMAND OPTIONS</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        --platform=PLATFORM  Override default platform. Can be any Docker</span></span>
<span class="line"><span>                             platform.</span></span>
<span class="line"><span>        --[no-]dry-run       Print the commands that would be run and</span></span>
<span class="line"><span>                             don&#39;t actually do anything. Implies --skip-checks</span></span>
<span class="line"><span>        --[no-]skip-checks   Skip checks for code having been</span></span>
<span class="line"><span>                             committed and pushed</span></span>
<span class="line"><span>        --[no-]deploy        After images are pushed, actually deploy them</span></span>
<span class="line"><span>        --[no-]push          After images are created, push them</span></span>
<span class="line"><span>                             to Heroku&#39;s registry. If false,</span></span>
<span class="line"><span>                             implies --no-deploy</span></span></code></pre></div></li><li><p>Try building images first: <code>bin/deploy deploy --no-push --skip-checks</code></p></li><li><p>It&#39;s possible to run the images locally. If you are on Apple Silicon, you&#39;ll need to set --platform:</p><ul><li><code>bin/deploy deploy --no-push --skip-checks --platform linux/arm64</code></li><li>Create <code>docker-compose.yml</code> for your image and any other services e.g. databases</li><li>Set required environment variables in <code>docker-compose.yml</code></li><li>Start up Docker compose and poke around</li></ul><p>You&#39;ll need to have a better understanding of Docker to do this, however if you are deploying with Docker, this is an understanding you hopefully already have.</p></li></ul><h3 id="other-mechanisms-for-deployment" tabindex="-1">Other Mechanisms for Deployment <a class="header-anchor" href="#other-mechanisms-for-deployment" aria-label="Permalink to &quot;Other Mechanisms for Deployment&quot;">​</a></h3><p>As a Rack app, other deployments should be possible. To make the app work, you&#39;ll need to make sure a few things are dealt with:</p><ul><li><code>RACK_ENV</code> <strong>must</strong> be <code>&quot;production&quot;</code></li><li><code>bin/build-assets</code> will build all assets by default. This must either be done on production servers or done ahead of time and the results packaged with the app.</li><li><code>bin/build-assets</code> outputs files in <code>app/public</code> and <code>app/config</code>. Those files are used at runtime. Brut <strong>will not</strong> initiate the build of any assets.</li><li>If you are going to build assets on production servers, you <em>must</em> included developer tooling. This means NodeJS, all modules in <code>package.json</code> and all RubyGems in <code>Gemfile</code>.</li></ul><p>The <code>deploy/Dockerfile</code> created by <code>mkbrut --segment-heroku</code> is not very Heroku-specific and could serve as a reference.</p><h2 id="testing" tabindex="-1">Testing <a class="header-anchor" href="#testing" aria-label="Permalink to &quot;Testing&quot;">​</a></h2><p>Testing deployments is a bit out of scope, but in general:</p><ul><li>A container-based deployment can theoretically be run on your computer as a test.</li><li>Non-production, but production-like environments can be used to validate production configurations.</li><li>You own the means of production…not Brut.</li></ul><h2 id="recommended-practices" tabindex="-1">Recommended Practices <a class="header-anchor" href="#recommended-practices" aria-label="Permalink to &quot;Recommended Practices&quot;">​</a></h2><ul><li>Avoid a lot of code that checks <code>Brut.container.project_env</code>. Try to consolidate all prod/test/dev differences in environment variables.</li><li>Have a way to get a shell into your production environment for debugging.</li><li>Brut doesn&#39;t log much, but if you remove the <code>OTEL_*</code> environment variables, Brut will log OTel telemetry to the console, which may be useful.</li><li>Setting <code>OTEL_LOG_LEVEL=debug</code> is advised if the app isn&#39;t starting or you aren&#39;t seeing any telemetry or logging</li></ul><h2 id="technical-notes" tabindex="-1">Technical Notes <a class="header-anchor" href="#technical-notes" aria-label="Permalink to &quot;Technical Notes&quot;">​</a></h2><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p>Technical Notes are for deeper understanding and debugging. While we will try to keep them up-to-date with changes to Brut&#39;s internals, the source code is always more correct.</p></div><p><em>Last Updated July 3, 2025</em></p><p>None at this time.</p>`,25)])])}const m=a(t,[["render",p]]);export{h as __pageData,m as default};
