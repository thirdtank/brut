import{_ as t,c as o,o as a,ag as r}from"./chunks/framework.1L-BeKqY.js";const p=JSON.parse('{"title":"Security","description":"","frontmatter":{},"headers":[],"relativePath":"security.md","filePath":"security.md"}'),i={name:"security.md"};function n(s,e,c,l,d,u){return a(),o("div",null,e[0]||(e[0]=[r('<h1 id="security" tabindex="-1">Security <a class="header-anchor" href="#security" aria-label="Permalink to &quot;Security&quot;">​</a></h1><p>As a new framework, Brut has not been battle-tested against potential securitiy exploits. That said, Brut does configure several features to help manage security issues.</p><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>Web application security is a large topic. Brut provides a few features out of the box to manage security of your app:</p><ul><li>Encrypted sessions</li><li>Cross-Site Request Forgery (CSRF) protection</li><li>Content Security Policy headers and tools</li><li><code>bundle audit</code></li></ul><h3 id="encrypted-sessions" tabindex="-1">Encrypted Sessions <a class="header-anchor" href="#encrypted-sessions" aria-label="Permalink to &quot;Encrypted Sessions&quot;">​</a></h3><p>Brut uses the <code>Rack::Session::Cookie</code> middleware to manage cookies. They are encrypted with the value of the environment variable <code>SESSION_SECRET</code>. This prevents both the website visitor and other websites from examining the contents of the cookie.</p><p>This means that if Brut places data in there, it can rely on it being safe when fetched later.</p><p>Cookie behavior and configuration is currently not configurable.</p><h3 id="csrf-protection" tabindex="-1">CSRF Protection <a class="header-anchor" href="#csrf-protection" aria-label="Permalink to &quot;CSRF Protection&quot;">​</a></h3><p>A <a href="https://owasp.org/www-community/attacks/csrf" target="_blank" rel="noreferrer">cross-site request forgery</a> happens when a malicious site submits information from their site to a Brut-powered site, assuming it will allow and respect your credentials, potentially initiating an action on the Brut-powered site that you did not intend.</p><p>The common way to mitigate this is to require a CSRF token to be included with each form submission. This value is generated by the server and included int he user&#39;s secure session. If the form submission&#39;s CSRF token matches, the request is assumed to be valid.</p><p>Brut configures <a href="https://sinatrarb.com/rack-protection/" target="_blank" rel="noreferrer">Rack::Protection::AuthenticityToken</a> as a middleware. Its configuration requires that <em>all</em> form submissions include a valid CSRF token, with a few exceptions noted in the <a href="#technical-notes">Technical Notes</a> section below.</p><p>To include a valid CSRF token in your <a href="/forms.html">form</a>, use <a href="/api/Brut/FrontEnd/Components/FormTag.html" target="_self" rel="noopener" data-no-router><code>Brut::FrontEnd::Components::FormTag</code></a> to generate your <code>&lt;form&gt;</code>. That&#39;s it.</p><p>Brut&#39;s approach to Ajax requests is to model them as form submissions, so by creating a form using <code>FormTag</code> and using its <a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData" target="_blank" rel="noreferrer"><code>FormData</code></a> to submit that form with e.g. <code>fetch</code>, the CSRF token will be supplied.</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>AJax and CSRF is currently somewhat immature in Brut, so there may be areas where things don&#39;t work as you&#39;d expect.</p></div><h3 id="content-security-policy-headers-and-tools" tabindex="-1">Content Security Policy headers and tools <a class="header-anchor" href="#content-security-policy-headers-and-tools" aria-label="Permalink to &quot;Content Security Policy headers and tools&quot;">​</a></h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CSP" target="_blank" rel="noreferrer">Content Security Policy (CSP)</a> is a way for a website to tell the browser what CSS and JavaScript is allowed to execute on the page. Most web frameworks default to a lax or no policy, which makes applying one later difficult.</p><p>Brut takes the opposite approach. By default, Brut configures <a href="/api/Brut/FrontEnd/RouteHooks/CSPNoInlineStylesOrScripts.html" target="_self" rel="noopener" data-no-router><code>Brut::FrontEnd::RouteHooks::CSPNoInlineStylesOrScripts</code></a> as an after route hook. This sets the content security poilcy header to disallow all inline stylings (the <code>style=</code> attribute) and all inline script tags (e.g. <code>onclick=</code>). In development, inline styles are allowed, since they are convienient when prototyping.</p><p>Brut also configures CSP reporting, which is sent into the <a href="/instrumentation.html">instrumentation</a> system.</p><p>You can control this behavior by changing the <code>csp_class</code> and/or <code>csp_reporting_class</code> using <code>Brut.container.override</code> in your <code>App</code>. You can either create your own route hook and use that, or set either to <code>nil</code> to disable CSP entirely.</p><h3 id="bundle-audit" tabindex="-1"><code>bundle audit</code> <a class="header-anchor" href="#bundle-audit" aria-label="Permalink to &quot;`bundle audit`&quot;">​</a></h3><p>The <code>bin/ci</code> script provided when you created your Burt app includes a call to <code>bundle exec bundle audit check --update</code>, which will audit your RubyGems for versions that have known vulnerabilities. If any are found, <code>bin/ci</code> exits nonzero, thus failing your build.</p><h2 id="testing" tabindex="-1">Testing <a class="header-anchor" href="#testing" aria-label="Permalink to &quot;Testing&quot;">​</a></h2><p>In general, you don&#39;t want to test any of this unless you&#39;ve set up something custom or complex. Testing security is done more effectively by a third party evaluating your app as a so-called &quot;black box&quot; or &quot;opaque box&quot; where its probed for issues without knowing how the app is implemented.</p><h2 id="recommended-practices" tabindex="-1">Recommended Practices <a class="header-anchor" href="#recommended-practices" aria-label="Permalink to &quot;Recommended Practices&quot;">​</a></h2><ul><li>Do not disable CSRF protection.</li><li>Do not disable your content security policy. Use Brut&#39;s built-in and design your app to not require inline styles or scripts. It&#39;s much easier to not do this in the first place than to try to unwind it later.</li><li>Do not ship your app if <code>bundle audit</code> finds vulnerabilities.</li></ul><h2 id="technical-notes" tabindex="-1">Technical Notes <a class="header-anchor" href="#technical-notes" aria-label="Permalink to &quot;Technical Notes&quot;">​</a></h2><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p>Technical Notes are for deeper understanding and debugging. While we will try to keep them up-to-date with changes to Brut&#39;s internals, the source code is always more correct.</p></div><p><em>Last Updated June 13, 2025</em></p><h3 id="csrf-protection-1" tabindex="-1">CSRF Protection <a class="header-anchor" href="#csrf-protection-1" aria-label="Permalink to &quot;CSRF Protection&quot;">​</a></h3><p>CSRF protection is not required for <em>Brut-owned paths</em>, as defined by <a href="/api/Brut/FrontEnd/Middlewares/AnnotateBrutOwnedPaths.html" target="_self" rel="noopener" data-no-router><code>Brut::FrontEnd::Middlewares::AnnotateBrutOwnedPaths</code></a>. The reason for this is that these paths semantically should not be HTTP GETs, but are also not form submissions. They are currently used for locale detection and instrumentation, which we believe are OK to allow without CSRF protection.</p><p>This may change in the future.</p><h3 id="encrypted-sessions-1" tabindex="-1">Encrypted Sessions <a class="header-anchor" href="#encrypted-sessions-1" aria-label="Permalink to &quot;Encrypted Sessions&quot;">​</a></h3><p>Session cookies are set to expire after 1 year and use the value <code>Lax</code> for <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Cookies#controlling_third-party_cookies_with_samesite" target="_blank" rel="noreferrer"><code>SameSite</code></a>. &quot;Lax&quot; allows other sites to submit the Brut-powered site&#39;s cookies, but only if the user navigates to the site. They are not sent if another site submits an Ajax request. We feel this is the right tradeoff betweeen usability and security.</p><h3 id="content-security-policy-headers-and-tools-1" tabindex="-1">Content Security Policy headers and tools <a class="header-anchor" href="#content-security-policy-headers-and-tools-1" aria-label="Permalink to &quot;Content Security Policy headers and tools&quot;">​</a></h3><h3 id="bundle-audit-1" tabindex="-1"><code>bundle audit</code> <a class="header-anchor" href="#bundle-audit-1" aria-label="Permalink to &quot;`bundle audit`&quot;">​</a></h3>',37)]))}const m=t(i,[["render",n]]);export{p as __pageData,m as default};
